import os
import logging
from dotenv import load_dotenv
from typing import Optional

# Load environment variables from a local .env file (if present) before any code
# accesses them. This allows developers to keep secrets out of source and run
# the backend without exporting variables manually.
load_dotenv()

# Since LangChain v0.1+, ChatOpenAI lives in the provider package `langchain_openai`.
# Importing from the old namespace now fails unless `langchain_community` is installed.
# We switch to the new, explicit import.

from langchain_openai import ChatOpenAI  # type: ignore
from langchain.agents import Tool, AgentType, initialize_agent
from langchain.tools import tool
# AgentOps integration for monitoring LangChain runs
from agentops.integration.callbacks.langchain import LangchainCallbackHandler
from pydantic import BaseModel, Field, EmailStr

from database import appointments_collection
from email_service import send_email

# Configure logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


async def process_email_content(email_text: str, sender_email: Optional[str] = None) -> str:
    """Run the Bookly LangChain agent on an incoming email.

    The agent uses two tools:
    1. **send_email** – dispatches an email via SendGrid.
    2. **create_appointment** – stores an appointment in MongoDB and notifies participants.

    Behaviour:
    • The LLM decides whether the email needs clarification or contains sufficient details to schedule.
    • The agent invokes the appropriate tool(s) autonomously.
    • All side-effects (database writes, outgoing emails) happen inside those tool callbacks.

    Parameters
    ----------
    email_text : str
        Raw body of the incoming email to analyse.
    sender_email : str | None, optional
        Address of the original sender; provided so the agent can reply for clarifications.

    Returns
    -------
    str
        The final text response generated by the LLM after all tool invocations.
    """
    # Always rely on LLM-driven agent with tools.

    openai_key = os.getenv("OPENAI_API_KEY")
    if not openai_key:
        raise RuntimeError("OPENAI_API_KEY environment variable not set")

    # -------------------- DEFINE TOOLS --------------------

    class SendEmailArgs(BaseModel):
        to_emails: list[EmailStr] = Field(..., description="List of recipient email addresses")
        subject: str = Field(..., description="Subject of the email")
        content: str = Field(..., description="HTML or plain text content of the email body")

    @tool("send_email", args_schema=SendEmailArgs, return_direct=True, description="Send an email to one or more recipients.")
    def send_email_tool(to_emails: list[str], subject: str, content: str) -> str:  # type: ignore[valid-type]
        """Wrapper around SendGrid sending utility."""
        logger.info("[Tool] send_email -> %s", to_emails)
        send_email(to_emails, subject, content)
        return "Email sent."

    class CreateApptArgs(BaseModel):
        participants: list[EmailStr] = Field(..., description="Emails of meeting participants")
        datetime: str = Field(..., description="Date and time of the appointment")
        notes: str = Field("", description="Additional notes")

    @tool("create_appointment", args_schema=CreateApptArgs, return_direct=True, description="Create an appointment in the database and notify participants.")
    async def create_appointment_tool(participants: list[str], datetime: str, notes: str = "") -> str:  # type: ignore[valid-type]
        logger.info("[Tool] create_appointment -> participants=%s, datetime=%s", participants, datetime)
        appt_doc = {"participants": participants, "datetime": datetime, "notes": notes}
        insert_result = await appointments_collection.insert_one(appt_doc)
        appt_doc["id"] = str(insert_result.inserted_id)

        if participants:
            send_email(participants, "Appointment Scheduled", f"Your appointment has been scheduled. Details: {appt_doc}")
        return f"Appointment created with id {appt_doc['id']}"

    tools: list[Tool] = [send_email_tool, create_appointment_tool]  # type: ignore[arg-type]

    # -------------------- INITIALIZE AGENT --------------------

    # AgentOps callback for observability (requires AGENTOPS_API_KEY env variable)
    ao_handler = LangchainCallbackHandler()

    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0, callbacks=[ao_handler])

    system_prefix = (
        "You are Bookly, an appointment-management AI. "
        "You have two tools at your disposal: 'send_email' and 'create_appointment'. "
        "Use them to either ask for clarification or schedule a meeting as appropriate. "
        "DO NOT return the name of the tool in your response—just invoke the tool. "
        "If you need to clarify details, send an email to the original sender (whose address is provided). "
    )

    agent = initialize_agent(
        tools,
        llm,
        agent=AgentType.OPENAI_FUNCTIONS,
        verbose=True,
        callbacks=[ao_handler],
        agent_kwargs={"system_message": system_prefix},
    )

    # Run the agent with the email content and context.
    input_text = email_text
    if sender_email:
        input_text += f"\n\nSender email: {sender_email}"

    logger.info("[Agent] Starting agent run")
    result: str = await agent.arun(input_text)
    logger.info("[Agent] Completed agent run with result: %s", result)

    return result 